<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wormate Clone - Multiplayer Beta</title>
<style>
  /* Base Reset */
  body { 
    margin: 0; 
    overflow: hidden; 
    background: #0b0b12; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
  }
  canvas { display: block; }
  
  /* UI Layer */
  #ui-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
    display: none;
  }
  
  /* Minimap */
  #minimap-container {
    position: absolute; top: 20px; left: 20px;
    width: 150px; height: 150px; background: rgba(0,0,0,0.5);
    border-radius: 50%; border: 3px solid #333; overflow: hidden;
    pointer-events: auto; 
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }
  #minimap { width: 100%; height: 100%; display: block; }

  /* Leaderboard */
  #leaderboard {
    position: absolute; top: 20px; right: 20px; width: 200px;
    background: rgba(0, 0, 0, 0.6); color: white; padding: 15px; border-radius: 10px;
  }
  #leaderboard h3 { margin: 0 0 10px 0; text-align: center; color: #ffd700; }
  .lb-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
  .lb-me { color: #00ff00; font-weight: bold; }
  
  /* Connection Status */
  #status-msg {
    position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
    color: #ff3333; font-weight: bold; background: rgba(0,0,0,0.7);
    padding: 5px 15px; border-radius: 20px; display: none;
  }

  /* Game Over Screen */
  #game-over {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); display: none; flex-direction: column;
    justify-content: center; align-items: center; color: white; pointer-events: auto; z-index: 100;
  }
  #game-over h1 { font-size: 50px; color: #ff3333; margin-bottom: 20px; }
  
  .btn-group { display: flex; gap: 20px; }

  .menu-btn {
    padding: 15px 40px; font-size: 24px; color: white;
    border: none; border-radius: 30px; cursor: pointer; transition: transform 0.2s;
    font-weight: bold;
  }
  .btn-green { background: #00cc66; }
  .btn-green:hover { transform: scale(1.1); background: #00ee77; }
  
  /* Lobby Screen */
  #lobby {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(11, 11, 18, 0.95); display: flex; flex-direction: column;
    justify-content: center; align-items: center; z-index: 200;
  }
  #lobby h1 {
    font-size: 60px; color: #ffd700; margin-bottom: 10px;
    text-shadow: 0 0 20px #ff9900;
  }
  #nickname-input {
    padding: 15px; border-radius: 30px; border: 2px solid #444;
    background: #222; color: white; font-size: 20px; text-align: center;
    margin-bottom: 20px; outline: none; width: 250px;
  }
  #nickname-input:focus { border-color: #00cc66; }
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="status-msg">Connecting to server...</div>

<div id="lobby">
  <h1>WORMATE ONLINE</h1>
  <input type="text" id="nickname-input" placeholder="Nickname" value="Player" maxlength="12">
  <button class="menu-btn btn-green" onclick="startGame()">PLAY ONLINE</button>
  <p style="color: #666; margin-top: 20px;">Server: Frankfurt (Render)</p>
</div>

<div id="ui-layer">
  <div id="minimap-container"><canvas id="minimap"></canvas></div>
  <div id="leaderboard">
    <h3>Leaderboard <span id="online-count">(0)</span></h3>
    <div id="lb-content"></div>
  </div>
</div>

<div id="game-over">
  <h1>GAME OVER</h1>
  <p style="font-size: 24px; margin-bottom: 30px;">Score: <span id="final-score" style="color: #ffd700;">0</span></p>
  <button class="menu-btn btn-green" onclick="restartGame()">Play Again</button>
</div>

<script>
/* ================= CONFIGURATION ================= */
// YOUR RENDER SERVER URL
const SERVER_URL = "wss://snake-server-3bnw.onrender.com";

const CANVAS = document.getElementById("game");
const CTX = CANVAS.getContext("2d", { alpha: true, desynchronized: true });
const MINI_CANVAS = document.getElementById("minimap");
const MINI_CTX = MINI_CANVAS.getContext("2d");

const MAP_RADIUS = 3000; 
const SEGMENT_SPACING = 5;
const BASE_SPEED = 2.0;

let socket;
let myId = null;
let opponents = {}; // Stores other players: { id: { x,y,angle,path,color,name } }

/* ================= VARIABLES ================= */
let isGameRunning = false;
let isGameOver = false;
let zoom = 1.0;
let playerName = "Player";
let playerColor = "#ff66cc";

let head = { x: 0, y: 0, angle: 0 };
let length = 50;
let path = [];

let mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
let lastTime = performance.now();
let lastSendTime = 0;

/* ================= RESIZE ================= */
function resize() {
  CANVAS.width = window.innerWidth;
  CANVAS.height = window.innerHeight;
  MINI_CANVAS.width = 150;
  MINI_CANVAS.height = 150;
}
resize();
window.addEventListener("resize", resize);

/* ================= INPUT ================= */
window.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});
window.addEventListener("wheel", e => {
  zoom -= e.deltaY * 0.001;
  if(zoom < 0.3) zoom = 0.3;
  if(zoom > 1.5) zoom = 1.5;
}, { passive: true });

/* ================= NETWORKING ================= */
function connectToServer() {
    const statusEl = document.getElementById('status-msg');
    statusEl.style.display = 'block';
    statusEl.innerText = "Connecting...";

    socket = new WebSocket(SERVER_URL);

    socket.onopen = () => {
        console.log("Connected to Game Server");
        statusEl.style.display = 'none';
    };

    socket.onmessage = (event) => {
        const msg = JSON.parse(event.data);

        if (msg.type === 'init') {
            myId = msg.selfId;
            console.log("My ID is:", myId);
        }
        else if (msg.type === 'state') {
            // Update opponents list
            // Remove myself from the list so I don't draw myself twice
            const serverPlayers = msg.players;
            opponents = {};
            serverPlayers.forEach(p => {
                if (p.id !== myId) {
                    opponents[p.id] = p;
                }
            });
            updateLeaderboard();
        }
        else if (msg.type === 'remove') {
            delete opponents[msg.id];
        }
    };

    socket.onclose = () => {
        statusEl.style.display = 'block';
        statusEl.innerText = "Disconnected from Server";
    };
    
    socket.onerror = (err) => {
        console.error("Socket error", err);
    }
}

/* ================= GAME LOGIC ================= */
function startGame() {
  const input = document.getElementById('nickname-input');
  playerName = input.value.trim() || "Player";
  
  // Connect if not connected
  if (!socket || socket.readyState !== WebSocket.OPEN) {
      connectToServer();
  }

  document.getElementById('lobby').style.display = 'none';
  document.getElementById('ui-layer').style.display = 'block';
  document.getElementById('game-over').style.display = 'none';
  
  initGame();
}

function initGame() {
  // Random Spawn
  head.x = (Math.random() - 0.5) * 1000;
  head.y = (Math.random() - 0.5) * 1000;
  head.angle = Math.random() * Math.PI * 2;
  length = 50;
  path = [];
  
  // Init path
  for(let i=0; i<length*SEGMENT_SPACING; i+=SEGMENT_SPACING) {
      path.push({x: head.x, y: head.y});
  }

  playerColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
  
  isGameOver = false;
  isGameRunning = true;
  lastTime = performance.now();
  loop();
}

function restartGame() {
    initGame();
    document.getElementById('game-over').style.display = 'none';
}

function update(dt) {
  if (isGameOver || !isGameRunning) return;

  // Turning
  const dx = mouse.x - CANVAS.width / 2;
  const dy = mouse.y - CANVAS.height / 2;
  const dist = Math.hypot(dx, dy);

  if (dist > 20) {
    const targetAngle = Math.atan2(dy, dx);
    let diff = targetAngle - head.angle;
    while (diff < -Math.PI) diff += Math.PI * 2;
    while (diff > Math.PI) diff -= Math.PI * 2;
    head.angle += diff * 0.1; // Turn speed
  }

  // Move
  const speed = BASE_SPEED * dt;
  head.x += Math.cos(head.angle) * speed;
  head.y += Math.sin(head.angle) * speed;

  // Path Logic
  const last = path[path.length - 1];
  if (!last || Math.hypot(head.x - last.x, head.y - last.y) >= SEGMENT_SPACING) {
    path.push({ x: head.x, y: head.y });
  }
  const maxPath = length * SEGMENT_SPACING + 50;
  if (path.length > maxPath) path.splice(0, path.length - maxPath);

  // Map Boundaries
  if (Math.hypot(head.x, head.y) > MAP_RADIUS) {
      triggerGameOver();
  }

  // COLLISION (Client side check for simplicity)
  checkCollisions();

  // Send Data to Server (throttled to 20 times a second approx)
  const now = Date.now();
  if (now - lastSendTime > 50 && socket && socket.readyState === WebSocket.OPEN && myId) {
      socket.send(JSON.stringify({
          type: 'move',
          x: head.x,
          y: head.y,
          angle: head.angle,
          length: length,
          path: path, // Sending path to simple server
          name: playerName
      }));
      lastSendTime = now;
  }
}

function checkCollisions() {
    // Check against opponents
    for (const id in opponents) {
        const opp = opponents[id];
        if (!opp.path) continue;

        // Simple collision: Head hits Opponent Body
        for (let i = 0; i < opp.path.length; i += 3) { // Check every 3rd point
            const p = opp.path[i];
            const dist = Math.hypot(head.x - p.x, head.y - p.y);
            
            // 15 is approx radius sum
            if (dist < 20) {
                triggerGameOver();
                return;
            }
        }
    }
}

function triggerGameOver() {
    isGameOver = true;
    isGameRunning = false;
    document.getElementById('final-score').innerText = Math.floor(length * 10);
    document.getElementById('game-over').style.display = 'flex';
}

/* ================= RENDER ================= */
function draw() {
  CTX.fillStyle = "#0b0b12";
  CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
  
  if (!isGameRunning && !isGameOver) return; 

  CTX.save();
  CTX.translate(CANVAS.width / 2, CANVAS.height / 2);
  CTX.scale(zoom, zoom);
  CTX.translate(-head.x, -head.y);

  // Map Border
  CTX.beginPath();
  CTX.arc(0, 0, MAP_RADIUS, 0, Math.PI * 2);
  CTX.strokeStyle = "#ff3333";
  CTX.lineWidth = 20;
  CTX.stroke();
  CTX.fillStyle = "#161621";
  CTX.fill();

  // Draw Opponents
  for (const id in opponents) {
      const p = opponents[id];
      drawSnake(p.path, p.color, p.name, p.x, p.y);
  }

  // Draw Self
  drawSnake(path, playerColor, playerName, head.x, head.y);

  drawMinimap();
  CTX.restore();
}

function drawSnake(snakePath, color, name, headX, headY) {
    if (!snakePath || snakePath.length === 0) return;

    // Body
    CTX.lineWidth = 22;
    CTX.lineCap = "round";
    CTX.lineJoin = "round";
    CTX.strokeStyle = color;
    
    CTX.beginPath();
    CTX.moveTo(snakePath[0].x, snakePath[0].y);
    for (let i = 1; i < snakePath.length; i++) {
        CTX.lineTo(snakePath[i].x, snakePath[i].y);
    }
    CTX.lineTo(headX, headY);
    CTX.stroke();

    // Head
    CTX.fillStyle = color;
    CTX.beginPath();
    CTX.arc(headX, headY, 12, 0, Math.PI*2);
    CTX.fill();

    // Name
    CTX.fillStyle = "white";
    CTX.font = "14px Arial";
    CTX.textAlign = "center";
    CTX.fillText(name || "Guest", headX, headY - 20);
}

function drawMinimap() {
    MINI_CTX.clearRect(0,0,150,150);
    MINI_CTX.fillStyle = "rgba(0,0,0,0.5)";
    MINI_CTX.fillRect(0,0,150,150);

    const scale = 150 / (MAP_RADIUS * 2);
    
    // Draw opponents on minimap
    for(const id in opponents) {
        const op = opponents[id];
        const mx = 75 + op.x * scale;
        const my = 75 + op.y * scale;
        MINI_CTX.fillStyle = op.color || "red";
        MINI_CTX.beginPath();
        MINI_CTX.arc(mx, my, 3, 0, Math.PI*2);
        MINI_CTX.fill();
    }
    
    // Self
    const px = 75 + head.x * scale;
    const py = 75 + head.y * scale;
    MINI_CTX.fillStyle = "white";
    MINI_CTX.beginPath();
    MINI_CTX.arc(px, py, 4, 0, Math.PI*2);
    MINI_CTX.fill();
}

function updateLeaderboard() {
    const list = document.getElementById('lb-content');
    let html = '';
    // Simply counting players for now
    let count = 1; // Me
    for(let id in opponents) count++;
    document.getElementById('online-count').innerText = `(${count})`;

    // Add Me
    html += `<div class="lb-row lb-me"><span>${playerName}</span><span>${Math.floor(length*10)}</span></div>`;
    // Add Others
    for(let id in opponents) {
        const p = opponents[id];
        html += `<div class="lb-row"><span>${p.name}</span><span>${Math.floor(p.length*10)}</span></div>`;
    }
    list.innerHTML = html;
}

/* ================= LOOP ================= */
function loop() {
  requestAnimationFrame(loop);
  const now = performance.now();
  const dt = (now - lastTime) / (1000 / 60);
  lastTime = now;
  
  update(dt);
  draw();
}

// Start connection check immediately
connectToServer();

</script>
</body>
</html>
